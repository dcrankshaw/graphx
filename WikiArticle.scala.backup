
////////////////////////////////////////////////////////////

import java.util.regex.Pattern
import java.util.regex.Matcher
import scala.util.matching.Regex
import scala.collection.mutable
import scala.xml._
import org.apache.spark.serializer.KryoRegistrator


object WikiArticle {
  @transient val titlePattern = "<title>(.*)<\\/title>".r
  @transient val redirectPattern = "#REDIRECT\\s+\\[\\[(.*?)\\]\\]".r
  @transient val disambigPattern = "\\{\\{disambig\\}\\}".r
  @transient val stubPattern = "\\-stub\\}\\}".r
  @transient val linkPattern = Pattern.compile("\\[\\[(.*?)\\]\\]", Pattern.MULTILINE) 

  // def apply(wt: String): WikiArticle = {
  //   var red = false
  //   var st = false
  //   var dis = false
  //   var rel = false
  //   var li = null.asInstanceOf[Array[String]]
  //   if (!redirectPattern.findFirstIn(wt).isEmpty) { red = true }
  //   if (!stubPattern.findFirstIn(wt).isEmpty) { st = true }
  //   if (!disambigPattern.findFirstIn(wt).isEmpty) { dis = true }
  //   // only relevant if article is not a stub, disambiguation, or redirect
  //   rel = !(st || dis || red)
  //   if (rel) {
  //     li = parseLinks(wt)
  //   }
  //   // from https://github.com/apache/mahout/blob/mahout-0.8/integration/src/main/java/org/apache/mahout/text/wikipedia/WikipediaMapper.java
  //   val tiXML = titlePattern.findFirstIn(wt).getOrElse("")
  //   val ti = XML.loadString(tiXML).text
  //   new WikiArticle(wt, li, red, st, dis, rel, ti)
  // }


  private def parseLinks(wt: String): Array[String] = {
    val linkBuilder = new mutable.ArrayBuffer[String]()
    val matcher: Matcher = linkPattern.matcher(wt)
    while (matcher.find()) {
      val temp: Array[String] = matcher.group(1).split("\\|")
      // println(temp.deep.mkString("\n"))
      if (temp != null && temp.length > 0) {
        val link: String = temp(0)
        if (link.contains(":") == false) {
          linkBuilder += link
        }
      }
    }
    return linkBuilder.toArray
  }

  // substitute underscores for spaces and make lowercase
  private def canonicalize(title: String): String = {
    title.trim.toLowerCase.replace(" ", "_")
  }

  // Hash of the canonical article name. Used for vertex ID.
  private def titleHash(title: String) = { math.abs(canonicalize(title).hashCode) }

}


// case class WikiArticle(wtext: String, links: Array[String], redirect: Boolean, stub: Boolean, disambig: Boolean, relevant: Boolean, title: String) {
class WikiArticle(wtext: String) extends Serializable {
  val links: Array[String] = WikiArticle.parseLinks(wtext)
  @transient val neighbors = links.map(WikiArticle.titleHash).distinct
  @transient lazy val redirect: Boolean = !WikiArticle.redirectPattern.findFirstIn(wtext).isEmpty
  @transient lazy val stub: Boolean = !WikiArticle.stubPattern.findFirstIn(wtext).isEmpty
  @transient lazy val disambig: Boolean = !WikiArticle.disambigPattern.findFirstIn(wtext).isEmpty
  val relevant: Boolean = !(redirect || stub || disambig)
  @transient lazy val tiXML = WikiArticle.titlePattern.findFirstIn(wtext).getOrElse("")
  val title = XML.loadString(tiXML).text
  val vertexID = WikiArticle.titleHash(title)
  val edges = neighbors.map { n => Edge(vertexID, n, 1.0) }
}
